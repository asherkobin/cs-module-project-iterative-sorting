# Module Project - Iterative Sorting

## Algorithms

## Iterative Sorting

## Objectives

- describe the differences between Linear and Binary Search algorithms
- define what runtime complexity is, differentiate between various classifications and categorize the performance of an algorithm using Big O notation
- distinguish when to use, classify the performance, and implement code to conduct classic iterative sorting algorithms

## Introduction

In this project, you will be implementing many different solutions to the same problem: sort a list of integers in ascending order. You will also be using your newfound knowledge of complexity analysis to evaluate each implementation for efficiency.

Although sorting may seem like a trivial task, this project allows you to begin practicing classifying and categorizing the performance of different algorithms. Practicing your ability to classify the performance of these simple algorithms will make it easier for you to classify more sophisticated algorithms as you continue your journey of mastering Computer Science fundamentals. It will also help you to see that even trivial computation tasks embedded in your programs are essential for you to understand. Understanding these details is part of what will make you an excellent programmer and developer.

As you begin interviewing for jobs, you will often be expected to be able to implement, classify, and deeply understand these classic sorting algorithms.

## Instructions and/or completion requirements

1. Open up the [iterative_sorting](src/iterative_sorting) directory
2. Read through the descriptions of the `bubble_sort` and `selection_sort` algorithms
3. Implement `bubble_sort` and `selection_sort` in [iterative_sorting.py](src/iterative_sorting/iterative_sorting.py)
4. Test your implementation by running `test_iterative.py`

## Resources [TODO]

This section includes links to any required or supplemental materials. These may consist of documents an instructor or curriculum developer explicitly created for the course, or external references and examples and that relate to/inform/shed light on the module challenge.

[Assignment help](example)

[Examples in a real-world context](example)

[Documentation of gotchas](example)

[FAQ](example)

## Stretch goals [TODO]

Describe the tasks and features that would demonstrate a student's exceptional mastery of these principles — going above and beyond — but that exceeds what is required by the minimum expectations of the module challenge.

You can do this with full paragraphs, numbered lists,

- [ ]  or
- [ ]  by
- [ ]  using
- [ ]  a
- [ ]  checklist

## Tests [TODO]

Not every module (or every course) will require this section.

However, courses and modules with significant programming components may find it useful to include information/instruction regarding any code tests that the students may or may not be required to run to verify they've produced a passing solution.

If you include tests, describe how to run them, and any setup required. Be as detailed as possible – testing is an area many of our students struggle with.

> Test 1

- Instructions

## FAQs [TODO]

**What should I include in this section?**

*Include the answers to frequently asked questions as they come up. If it's a new module challenge, try to answer a few of the questions you think students might ask. Think ahead to potential roadblocks for an amateur.*

## Submission format [TODO]

Describe how the student should deliver the completed challenge. If it's step-by-step,

1. include
2. a
3. numbered
4. list.

## Grading rubric [TODO]

If you've prepared a grading rubric to evaluate the quality of a student's work on your module challenge assignment, include any instructions or relevant links below.

[Click here to see a grading rubric example](https://docs.google.com/spreadsheets/d/1uvNeQZtIXFXUGSPBtBdA3C7Pen8ayjLPcaHahcEiVkI/edit#gid=0)

[Module challenge grading rubric](https://www.notion.so/0ea69725e5664354a4338553a175e757)
